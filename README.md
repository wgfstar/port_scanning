## port_scanning
在渗透测试的初步阶段通常我们都需要对攻击目标进行信息搜集，而端口扫描就是信息搜集中至关重要的一
个步骤。通过端口扫描我们可以了解到目标主机都开放了哪些服务，甚至能根据服务猜测可能存在某些漏
洞。TCP端口扫描一般分为以下几种类型：
1. TCP connect扫描：也称为全连接扫描，这种方式直接连接到目标端口，完成了TCP三次握手的过程，这种方式扫描结果比较准确，但速度比较慢而且可轻易被目标系统检测到。
2. TCP SYN扫描：也称为半开放扫描，这种方式将发送一个SYN包，启动一个TCP会话，并等待目标响应数据包。如果收到的是一个RST包，则表明端口是关闭的，而如果收到的是一个SYN/ACK包，则表示相应的端口是打开的。
3. Tcp FIN扫描：这种方式发送一个表示拆除一个活动的TCP连接的FIN包，让对方关闭连接。如果收到了一个RST包，则表明相应的端口是关闭的。
4. TCP XMAS扫描：这种方式通过发送PSH、FIN、URG、和TCP标志位被设为1的数据包。如果收到了一个RST包，则表明相应的端口是关闭的。
</br>
本次实验使用Python3实现tcp全连接端口扫描。其中相关实现参考网上资料，通过编码实现，加深对端口扫描的认识</br>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

以下对主要代码及思路进行说明：</br>
* connScan（）、portScan（）：测试当前主机和端口是否开放，直接使用socket连接</br>
* 为了捕获我们的目标主机的应用标识，我们必须首先插入额外的验证代码到 connScan函数中。一旦发现开放的端口，我们发送一个字符串数据到这个端口然后等待响应。收集这些响应并推断可能会得到运行在目标主机端口上的应用程序的一些信息。
* 多线程扫描：因为每一个socket都有时间延迟，每一个socket扫描都将会耗时几秒钟，虽然看起来无足轻重，但是如果我们扫描多个端口和主机延迟时间将迅速增大。 理想情况下，我们希望这些socket按顺序扫描。引入Python线程。线程提供了一种同时执行的方式。在我们的扫描中利用线程，可以把每一个connScan()函数都当做是一个线程。在迭代的过程中产生的每一个线程将在同时执行。</br>

```
 for tgtPort in tgtPorts:
     print('Scanning port ' + str(tgtPort))
     t = threading.Thread(target=connScan, args=(tgtHost, int(tgtPort)))
     t.start()

